package io.github.maybeec.patterndetection.common;

import java.awt.Graphics;
import java.awt.image.BufferedImage;
import java.io.File;
import java.io.FileReader;
import java.io.Reader;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Future;

import javax.imageio.ImageIO;
import javax.swing.JFrame;

import org.antlr.v4.gui.TreeViewer;
import org.antlr.v4.gui.Trees;
import org.antlr.v4.runtime.ANTLRInputStream;
import org.antlr.v4.runtime.CommonTokenStream;
import org.antlr.v4.runtime.Parser;
import org.antlr.v4.runtime.ParserRuleContext;
import org.antlr.v4.runtime.atn.PredictionMode;

import io.github.maybeec.parsers.javatemplate.JavaTemplateLexer;
import io.github.maybeec.parsers.javatemplate.JavaTemplateParser;

/**
 * TODO to be generated by ANTLR4 Tools
 */
public class CommonParseTools {

    /** If true, all runs will be printed to png into the project root */
    private static final boolean PRINT_TO_PNG = false;

    /** If true, all runs will be printed to eps into the project root */
    private static final boolean PRINT_EPS = false;

    /**
     * @see #parse(File, PredictionMode, boolean, boolean)
     */
    @SuppressWarnings("javadoc")
    public static ParserRuleContext parse(File file, PredictionMode predictionMode, boolean debug) throws Exception {
        return parse(file, predictionMode, false, debug).get(0);
    }

    /**
     * @see #parse(File, PredictionMode, boolean, boolean)
     */
    @SuppressWarnings("javadoc")
    public static List<ParserRuleContext> parseAmbiguities(File file, PredictionMode predictionMode, boolean debug)
        throws Exception {
        return parse(file, predictionMode, true, debug);
    }

    /**
     * Parse a java file with the given prediction mode and return the parse trees. If debug is enabled, the
     * test blocks to show the parsed trees in a UI view.
     * @param file
     *            to be parsed
     * @param predictionMode
     *            prediction mode to be used for parsing.
     * @param parseAmbiguities
     *            states if ambiguities should be parsed as well
     * @param debug
     *            if true, the test blocks for each parsed tree and shows it in a graph UI for debugging.
     * @return the parse trees
     * @throws Exception
     *             test fails
     */
    private static List<ParserRuleContext> parse(File file, PredictionMode predictionMode, boolean parseAmbiguities,
        boolean debug) throws Exception {
        PredictionMode.resetAmbiguityData();

        // template parsing
        Reader reader = new FileReader(file);
        JavaTemplateLexer lexer = new JavaTemplateLexer(new ANTLRInputStream(reader));
        JavaTemplateParser parser = new JavaTemplateParser(new CommonTokenStream(lexer));

        parser.removeErrorListeners();
        parser.addErrorListener(new ErrorListener());
        parser.getInterpreter().setPredictionMode(predictionMode);

        List<ParserRuleContext> trees = new ArrayList<>();
        int count = 0;
        long start = System.nanoTime();
        do {
            ParserRuleContext tree;
            System.out.println("start parsing");
            try {
                tree = parser.compilationUnit();
                trees.add(tree);
                showTreeUI(debug, parser, tree);
            } catch (ANTLRParseException e) {
                System.out.println("parsing not successfull!");
                System.out.println("FILE: " + file.getAbsolutePath());
                System.out.println("ERROR: " + e.getMessage());
                e.printStackTrace();
                throw e;
            }
            System.out.println("parsing complete");

            if (parseAmbiguities) {
                parser.reset();
                System.out.println("Number of ambiguities detected: " + PredictionMode.getAmbiguityCounter());
                PredictionMode.updateAmbiguityDataForNextRun();
            }
            count++;

            printToFile(file, parser, count, tree);
        } while (parseAmbiguities && PredictionMode.hasNextRun());

        long end = System.nanoTime();

        System.out.println(count + " trees parsed in " + ((end - start) / Math.pow(10, 9)) + "s");
        return trees;
    }

    /**
     * @param debug
     * @param parser
     * @param tree
     * @throws InterruptedException
     * @throws ExecutionException
     */
    private static void showTreeUI(boolean debug, JavaTemplateParser parser, ParserRuleContext tree)
        throws InterruptedException, ExecutionException {
        if (debug) {
            Future<JFrame> future = Trees.inspect(tree, parser);
            while (future.get().isVisible()) {
                try {
                    Thread.sleep(100);
                } catch (InterruptedException e) {
                }
            }
        }
    }

    /**
     * Prints eps as well as png files for a given tree.
     * @param file
     *            to retrieve the filename from
     * @param parser
     *            the tree is parsed from
     * @param count
     *            running counter for file naming
     * @param tree
     *            to be printed
     * @throws Exception
     *             if anything went wrong
     */
    private static void printToFile(File file, Parser parser, int count, ParserRuleContext tree) throws Exception {
        String fileName = file.getName() + "_" + count;
        if (PRINT_EPS) {
            Trees.save(tree, parser, fileName + ".eps", "Calibri", 8);
        }

        if (PRINT_TO_PNG) {
            TreeViewer treeViewer = new TreeViewer(new ArrayList<>(Arrays.asList(parser.getRuleNames())), tree);
            Future<JFrame> future = treeViewer.open();
            future.get();

            BufferedImage bi = new BufferedImage(treeViewer.getPreferredSize().width,
                treeViewer.getPreferredSize().height, BufferedImage.TYPE_INT_ARGB);
            Graphics g = bi.createGraphics();
            treeViewer.paint(g);
            g.dispose();
            ImageIO.write(bi, "png", new File(fileName + ".png"));

            future.cancel(true);
        }
    }
}
